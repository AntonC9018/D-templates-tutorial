\newpage
\part{Examples}\label{examples}

This part will present various examples showing what can be done with D templates, be it type manipulation, code generation or language extension \ldots Most examples are code snippets that were useful to me at one time or another. I hope they will be useful to you too.

\aparte{Contributors welcome!}{Even more than for other parts, I welcome any short and synthetic example of what can be done with templates. Do not hesitate to chime in and push some code in this doc!}

\section{Type Sorcery}\label{typesorcery}

One of the most fundamental use of templates is type sorcery: type creation, type manipulation, etc. D being a statically type language, all of your creations will have a defined type. Sometimes, these can be cumbersome to write or manipulate. Templates can help you in this.

\subsection{Mapping, Filtering and Folding Types}

As we saw in section \ref{tuples}, template tuple parameters can hold type tuples (that's even their original role). Since these can be iterated, indexed or sliced, they are ideal candidates to some standard iteration algorithms. As for ranges, you can map another template on type tuples, filter the types you want to extract or fold (reduce) them into another type.

\aparte{And non-types?}{What about acting on expression tuples? You can do that too. Even though this section is called \emph{Type} Sorcery, all templates here can work on expression tuples too. Do not feel limited.}

\subsubsection{Mapping on Type Tuples}\label{staticmap}

Mapping a type tuple is simply applying another (unary) template on all types of a type tuple. Phobos already defines \DD{staticMap} in \std{typetuple}, but it's a nice exercise to code it again. We want a template that takes another template name (as an \D{alias} parameter), say \DD{Wrapper}, and a typetuple (\DD{T0, T1, T2, ..., Tn}) and returns \DD{Wrapper!T0, Wrapper!T1, Wrapper!T2, ..., Wrapper!Tn}.

\begin{dcode}
template staticMap(alias M, T...)
{
    static if (T.length == 0) // End of sequence
        alias TypeTuple!() staticMap; // stop there
    else
        alias TypeTuple!(M!(T[0]), staticMap!(M, T[1..$])) staticMap;
}
\end{dcode}

We use the auto-flattening of type tuples to aggregate the results into a unique tuple. Notice how indexing and slicing make for a not-so-complicated piece of code.

Even a simple template such as this one can have great uses:

\begin{itemize}
\item Getting rid of all qualifiers in a type list, by mapping \stdanchor{traits}{Unqual} on the types.
\item Generating a huge quantity of types by using a typetuple-returning mapper (see below).
\item Given a bunch of function types, getting their return types or parameter typetuples.
\end{itemize}

The seconde use can be useful to unit-test a part of your code. Suppose you have a templated function that is supposed to work on any built-in type. You do not need to generate all possible combinations of types. Just use \DD{staticMap} to generate them for you:

\begin{dcode}
/** 
* Given a type T, generates all qualified versions of T
* that you find interesting (eleven versions all in all).
*/
template Qualified(T)
{
    alias TypeTuple!(
                     T, const(T), immutable(T), shared(T),
                     T[],const(T)[],immutable(T)[], shared(T)[], 
                     const(T[]), immutable(T[]), shared(T[])
                    ) Qualified;
}

// All 16 built-in types you're interested in.
alias TypeTuple!(
                 bool,
                 ubyte,byte,
                 ushort,short,
                 uint,int,
                 ulong,long,
                 float,double,real,
                 char,wchar,dchar
                ) ValueTypes;

// Bang, 11*16 types generated.
alias staticMap!(Qualified,ValueTypes) QualifiedTypes;

// If you're really a pervert (note that there will be duplicates)
alias staticMap!(Qualified, QualifiedTypes) DoublyQualifiedTypes;
\end{dcode}

Now, if your function is supposed to work on all the generated qualified types, just test it:

\begin{dcode}
void myFun(T)(T t) { ... }

unittest {
    /* Here we generate the qualified types, see above */
    (...)
    
    template test(alias fun)
    {
        void on(T...)()
        {
            foreach(Type; T)
                static if (!__traits(compiles, fun(Type.init)))
                    pragma(msg, "Bad testing combination: " 
                               ~ fun.stringof ~ " and " ~ Type.stringof);
        }
    }
    
    test!(myFun).on!(QualifiedTypes);
}
\end{dcode}

\subsubsection{Filtering Type Tuples}\label{staticfilter}

You can search for and extract some types from a tuple, using a predicate to chose which type (or more generally, which tuple element) you want to keep. A predicate in this particular case means 'a template that, when given a type as argument, will return either \D{true} or \D{false}'. The test done on the tuple element can be as complicated as you want, particularly using \D{is}\DD{()} expressions (see \autoref{isexpression}).

That gives us the following code:

\begin{dcode}
template staticFilter(alias Pred, T...)
{
    static if (T.length == 0) // End of sequence
        alias TypeTuple!() staticFilter;
    else static if (Pred!(T[0])
        alias TypeTuple!(T[0], staticFilter!(Pred, T[1..$])) staticFilter;
    else
        alias TypeTuple!(      staticFilter!(Pred, T[1..$])) staticFilter;
}
\end{dcode}

Using \DD{staticFilter} is quite simple. Let's get integral types from a tuple, by way of \stdanchor{traits}{isIntegral}:

\begin{dcode}
alias TypeTuple!(int, double, float, string, byte, bool, float, void) Types;

alias staticFilter!(isIntegral, Types) OnlyIntegrals;

static assert(is(OnlyIntegrals == TypeTuple!(int, byte, bool)));
\end{dcode}

But that is, admittedly, pretty boring stuff. Though useful from time to time, it's quite rare for someone to be given a pure type tuple like this. A much more common use for the likes of \DD{staticFilter} is when creating complex types.

As a first example, imagine you have a \DD{Graph(Node, Edge)} struct, templated on the nodes (vertice) and edges types (themselves templated). When you create a \DD{Graph} with a factory function (\ref{factory}), it would be nice to be able to mix nodes and edges in a natural way. That is, given \DD{graph}, \DD{node} and \DD{edge} functions that do the obvious thing, you want to autorize calls like:

\begin{dcode}
/** 
* Automatically creates a graph 
*   - with four nodes labelled "A", "B", "C", "D", holding a double, 
*   - with nodes linking "A" to "B", "D" to "A" and "D" to "C".
*/
auto g = graph(node("A", 3.14159), node("B", 1.0), 
               edge("A","B"),
               node("C", 2.71828), node("D", 0.0), 
               edge("D","A"), edge("D", "C"));
\end{dcode}

This allows the user building her \DD{Graph} to create nodes and edges between these nodes in a natural way (as opposed to, say, batch-building all nodes and then adding edges between them). But, as a library writer, that means your \DD{graph} factory function has the following signature:

\begin{dcode}
auto graph(NodesOrEdges...)(NodesOrEdges args) 
if (/* sanity check test on NodesOrEdges */)
\end{dcode}

Both the sanity check performed by the template constraint (\ref{constraints}) and the building code inside \DD{graph} can be quite complicated. \DD{staticFilter} helps by separating the arguments between nodes and edges. Without extending this example too much, say we have at our disposal the following predicate templates:

\begin{dcode}
template isNode(N) {/* true iff N is a Node!(LabelType, ValueType)*/}
template isEdge(E) {/* true iff E is an Edge!(LabelType)*/}

template isNodeOrEdge(T)
{
    static if (isNode!T || isEdge!T)
        enum isNodeOrEdge = true;
    else
        enum isNodeOrEdge = false;
}
\end{dcode}

And let's suppose also all \emph{bona fide} \DD{Node}s and \DD{Edge}s have  \DD{.LabelType}/\DD{.ValueType} members exposing their inner types (as shown in section \ref{inneralias}).

Then, getting all nodes and edges is easy:
\begin{dcode}
alias staticFilter!(isNode, NodesOrEdges) Nodes;
alias staticFilter!(isEdge, NodesOrEdges) Edges;
\end{dcode}

This is where things get interesting: obtaining the edges and nodes types is just a first building block. Now \DD{graph} must check at a minimum the following elements:

\begin{enumerate}
\item All arguments must be nodes or edges.
\item Is there at least \emph{one} node in the list?
\item If yes, do all nodes have the same \DD{LabelType} and the same \DD{ValueType}, or, at least, is there a common type between all the labels' types and another one for the values stored in the nodes?
\item Do edges' \DD{LabelTypes} have a common type? (Note that there can be zero edges).
\item Do the edges labels have the correct type to refer to the provided nodes?
\end{enumerate}

Note that \emph{all} these checks are done only on types and thus can be done at compile-time, thereby ensuring a pretty solid static check on the graph built. What cannot be done in this way is verifying during compilation that edges do indeed refer to existing nodes.

Let's use what we have seen until now to create the \DD{GraphCheck} template, before seeing another \DD{staticFilter} example:

\begin{dcode}
import std.traits: CommonType;

template GraphCheck(NodesOrEdges...)
{
    enum GraphCheck = GraphCheckImpl!(NodesOrEdges).result;
}

template GraphCheckImpl(NodesOrEdges...)
{
    alias staticFilter!(isNode, NodesOrEdges) Nodes;
    alias staticFilter!(isEdge, NodesOrEdges) Edges;
    
    // 1. All arguments must be nodes or edges
    static if (Nodes.length + Edges.length != NodesOrEdges.length)
    static assert(0, "Some args are not nodes or edges.");
    
    // 2. There must be at least one node
    static if (Nodes.length == 0)
    static assert(0, "You must provide at least one node.");
    
    // 3. Is there a common type for the nodes' labels and values?
    // First step: extracting labels and values
    template GetLabel(T) if (isNode!T || isEdge!T)
    {
        alias T.LabelType GetLabel;
    }
    
    template GetValue(T) if (isNode!T)
    {
        alias T.ValueType GetValue;
    }

    alias staticMap!(GetLabel, Nodes) NodesLabels;
    alias staticMap!(GetValue, Nodes) NodesValues; 
    
    static if (is(CommonType!(NodesLabels) == void)) // no common type
    static assert(0, "The nodes do not have all the same label type.");
    
    static if (is(CommonType!(NodesValues) == void))
    static assert(0, "The nodes do not have all the same value type.");

    // 4. Same for edges
    alias staticMap!(GetLabel, Edges) EdgesLabels;  
    
    static if (is(CommonType!(EdgesLabels) == void))
    static assert(0, "The edges do not have all the same label type.");
        
    // 5. Edges - Node compatibility
    static if(!is(CommonType!NodesLabels == CommonType!EdgesLabels))
        static assert(0, "Nodes and edges do not have the same label type.");
    
    enum result = true;
}    
\end{dcode}

This is one huge template, but \DD{staticFilter} sits square in the middle and greatly simplifies the code. Now, \DD{graph} signature is simply:

\begin{dcode}
auto graph(NodesOrEdges...)(NodesOrEdges args) if (GraphCheck!NodesOrEdges)
{ ... }
\end{dcode}



\subsubsection{Folding Type Tuples}\label{staticreduce}

\subsection{Zipping Types, Interspersing Types, Crossing Types}

\begin{dcode}
/**
Helper template. Given T0, T1, T2, ..., Tn, Tn+1, ... T2n, will returns
the interleaving of the first part with the second part: T0, Tn+1, T1, Tn+2, ... Tn, T2n
It's fragile: no test, etc. A better way to do this would be as a two-steps template: Interleave!(T...).With!(U...)
*/
template Interleave(T...)
{
    static if (T.length > 1)
        alias TypeTuple!(T[0], T[$/2], Interleave!(T[1..$/2], T[$/2+1 .. $])) Interleave;
    else
        alias T Interleave;
}
\end{dcode}

\section{Relational Algebra}

Inspiration for this example comes from \href{http://david.rothlis.net/d/templates}{This blog article}.

\TODO{Extracting from a tuple: project, select. Also, natural/inner/outer join, cartesian product. And intersection/union/difference. rename!( "oldField", "newField"). Databases are just dynamic arrays of tuples.}.

\section{Cloning, sort of}

\TODO{(Elsewhere) creating a class from a struct?}

\section{Recording Successive States}

From Andrej Mitrovic.

\begin{dcode}
import std.stdio;
import std.traits;

struct Shape
{
    int x, y;
    void foo(int val) { x += val; }
    int bar(int val) { y += val; return y; }
}

struct RecorderImpl(T)
{
    T t;
    T[] t_states;
    
    this(T t)
    {
        this.t = t;
        t_states ~= t;
    }
    
    auto opDispatch(string method, Args...)(Args args)
    {
        static if (mixin("is(ReturnType!(t." ~ method ~ ") == void)"))
        {
            mixin("t." ~ method ~ "(args);");
            t_states ~= t;
        }
        else
        {
            mixin("auto result = t." ~ method ~ "(args);");
            t_states ~= t;
            return result;
        }
    }
    
    auto opIndex(size_t index)
    {
        assert(index < t_states.length);
        return t_states[index];
    }
    
    auto opSlice(size_t lowerBound, size_t upperBound)
    {
        return t_states[lowerBound..upperBound];
    }
    
    auto opSlice()
    {
        return t_states[];
    }
}

auto Recorder(T)(T t)
{
    return RecorderImpl!T(t);
}

void main()
{
    auto shape = Recorder(Shape(0, 0));
    
    shape.foo(5);
    shape.bar(5);
    
    writeln(shape[0]);
    writeln(shape[]);
}
\end{dcode}



\section{Fields}

From Jacob's Carlborg Orange.

\TODO{Test typeof(s.tupleof)}

\begin{dcode}
/**
 * Evaluates to an array of strings containing the names of the fields in the given type
 */
template fieldsOf (T)
{
	const fieldsOf = fieldsOfImpl!(T, 0);
}

/**
 * Implementation for fieldsOf
 * 
 * Returns: an array of strings containing the names of the fields in the given type
 */
template fieldsOfImpl (T, size_t i)
{
	static if (T.tupleof.length == 0)
		const fieldsOfImpl = [""];

	else static if (T.tupleof.length - 1 == i)
		const fieldsOfImpl = [T.tupleof[i].stringof[1 + T.stringof.length + 2 .. $]];

	else
		const fieldsOfImpl = T.tupleof[i].stringof[1 + T.stringof.length + 2 .. $] ~ fieldsOfImpl!(T, i + 1);
}
\end{dcode}

\section{Extending an enum}

\begin{dcode}
string EnumDefAsString(T)() if (is(T == enum)) {
  string result = "";
  foreach (e; __traits(allMembers, T)) {
      result ~= e ~ " = T." ~ e ~ ",";
  }
  return result;
}

template ExtendEnum(T, string s) if (is(T == enum) &&
is(typeof({mixin("enum a{"~s~"}");}))) {
  mixin("enum ExtendEnum {" ~
      EnumDefAsString!T() ~ s ~
  "}");
}

unittest {
  enum bar {
      a = 1,
      b = 7,
      c = 19
  }

  import std.typetuple;

  alias ExtendEnum!(bar, q{ // Usage example here.
      d = 25
  }) bar2;

  foreach (i, e; __traits(allMembers, bar2)) {
      static assert( e == TypeTuple!("a", "b", "c", "d")[i] );
  }

  assert( bar2.a == bar.a );
  assert( bar2.b == bar.b );
  assert( bar2.c == bar.c );
  assert( bar2.d == 25 );

  static assert(!is(typeof( ExtendEnum!(int, "a"))));
  static assert(!is(typeof( ExtendEnum!(bar, "25"))));
}

//(Simen Kjaeraas)
\end{dcode}

\section{Static Switching} \label{examples:staticswitch}

\TODO{What, no compile-time switch? Let's create one}.
Example of: tuples, type filtering (in constraints), recursion, etc.

\begin{dcode}
template staticSwitch(List...) // List[0] is the value commanding the switching
                               // It can be a type or a symbol.
{
    static if (List.length == 1) // No slot left: error
        static assert(0, "StaticSwitch: no match for " ~ List[0].stringof);
    else static if (List.length == 2) // One slot left: default case
        enum staticSwitch = List[1];
    else static if (is(List[0] == List[1]) // Comparison on types
                || (  !is(List[0])         // Comparison on values
                   && !is(List[1])
                   && is(typeof(List[0] == List[1]))
                   && (List[0] == List[1])))
        enum staticSwitch = List[2];
    else
        enum staticSwitch = staticSwitch!(List[0], List[3..$]);
}
\end{dcode}

\section{Gobble}\label{gobble}

\begin{dcode}

struct Gobbler(T...)
{
    T store;
    Gobbler!(T, string,U) opBinary(string op, U)(U u) if (op == "~")
    {
        return Gobbler!(T,string, U)(store, op, u);
    }
}

Gobbler!() gobble() { return Gobbler!()();}
\end{dcode}

\section{A Polymorphic Tree}\label{polymorphictree}

\section{Polymorphic Association Lists}\label{associationlists}

Usage: a bit like Lua tables: structs, classes (you can put anonymous functions in them?),  namespaces.
Also, maybe to add metadata to a type?

\begin{dcode}
template Half(T...)
{
    static if (T.length <= 1)
        alias TypeTuple!() Half;
    else
        alias TypeTuple!(T[0], Half!(T[2..$])) Half;
}

struct AList(T...)
{
    static if (T.length >= 2 && T.length % 2 == 0)
        alias Half!T Keys;
    else static if (T.length >= 2 && T.length % 2 == 1)
        alias Half!(T[0..$-1]) Keys;
    else
        alias TypeTuple!() Keys;

    static if (T.length >= 2)
        alias Half!(T[1..$]) Values;
    else
        alias TypeTuple!() Values;

    template at(alias a)
    {
        static if ((staticIndexOf!(a, Keys) == -1) && (T.length % 2 == 1)) // key not found, but default value present
            enum at = T[$-1]; // default value
        else static if ((staticIndexOf!(a, Keys) == -1) && (T.length % 2 == 0))
            static assert(0, "AList: no key equal to " ~ a.stringof);
        else //static if (Keys[staticIndexOf!(a, Keys)] == a)
            enum at = Values[staticIndexOf!(a, Keys)];
    }
}

alias AList!( 1,     "abc"
            , 2,     'd'
            , 3,     "def"
            , "foo", 3.14
            ,        "Default") al;

writeln("Keys: ", al.Keys);
writeln("Values: ", al.Values);
writeln("at!1: ", al.at!(1));
writeln("at!2: ", al.at!(2));
writeln("at!\"foo\": ", al.at!("foo"));
writeln("Default: ", al.at!4);
\end{dcode}

\section{Expression Templates}\label{expressiontemplates}

\section{Wrapping a Function}

Making it accept a tuple, for example.

\begin{dcode}
template tuplify(alias fun)
{
    auto tuplify(T...)(Tuple!T tup)
    {
        return fun(tup.expand);
    }
}
\end{dcode}

Another interesting (and much more complicated) example is \DD{juxtapose}.

\section{Mapping n ranges in parallel}\label{parallelmapping}

\begin{dcode}
// Very easy to do, now:
auto nmap(alias fun, R...)(R ranges) if (allSatisfy!(isInputRange,R))
{
    return map!(tuplify!fun)(zip(ranges));
}
\end{dcode}

More complicated: \stdanchor{algorithm}{map} accepts to take more than one function as template argument. In that case, the functions are all mapped in parallel on the range, internally using \stdanchor{functional}{adjoin}.
Here we can extend \DD{nmap} to accept $n$ functions in parallel too. There is a first difficulty:

\begin{dcode}
auto nmap(fun..., R...)(R ranges) if (allSatisfy!(isInputRange, R))
{ ... 
\end{dcode}

See the problem? Tuples must be the last parameter of a template: there can be only one. Double-stage templates come to the rescue:

\begin{dcode}
template nmap(fun...) if (fun.length >= 1)
{
    auto nmap(R...)(R ranges) if (allSatisfy!(isInputRange, R))
    {...}
}
\end{dcode}

Final code:

\begin{dcode}
template nmap(fun...) if (fun.length >= 1)
{
    auto nmap(R...)(R ranges) if (allSatisfy!(isInputRange, R))
    {
        alias adjoin!(staticMap!(tuplify, fun)) _fun;
        return map!(_fun)(zip(ranges));
    }
}
\end{dcode}

Give an example with \DD{max}, it works!

And here is the $n$-ranges version of \stdanchor{algorithm}{filter}:

\begin{dcode}
auto nfilter(alias fun, R...)(R ranges) if (allSatisfy!(isInputRange, R))
{
    return filter!(tuplify!fun)(zip(ranges));
}
\end{dcode}

\section{Statically-Checked Writeln}

\section{Extending a Class}\label{extendingaclass}

There is regularly a wish in the D community for something called Universal Function Call Syntax (UFCS):\index{syntax!Universal Function Call Syntax}\index{UFCS} the automatic transformation of \DD{a.foo(b)} into \DD{foo(a,b)} when \DD{a} has no member called \DD{foo} and there \emph{is} a free function called \DD{foo} in the local scope\index{scope!local scope}. This already works for arrays\index{arrays!UFCS} (hence, for strings) but not for other types.

There is no way to get that in D for built-in types except by hacking the compiler, but for user-defined types, you can call templates to the rescue.

\DD{opDispatch} can be used to forward to an external free function. A call \D{this}\DD{.method(a,b)} becomes \DD{method(}\D{this}\DD{,a,b)}.

\begin{dcode}
mixin template Forwarder
{
    auto opDispatch(string name, Args...)(Args args)
    {
        mixin("return " ~ name ~ "(args);");
    }
}
\end{dcode}

In D, a void \D{return} clause is legal: 

\begin{dcode}
return;
// or return void;
\end{dcode}

So if \DD{name(}\D{this}\DD{,a,b)} is a \D{void}-returning function, all is OK.

The main limitation of this trick is that it doesn't work across modules boundaries. Too bad.

\section{Pattern Matching With Functions}

\section{Generating a Switch for Tuples}
Case 0:, etc.

\section{Tuples as Sequences}

\subsection{Mapping on Tuples}

\subsection{Filtering Tuples}

\begin{dcode}
(1, "abc", 2, "def", 3.14)
->
((1,2),("abc","def"),(3,14))
\end{dcode}

