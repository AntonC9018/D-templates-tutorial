\newpage
\part{Examples}\label{examples}

This part will present various examples showing what can be done with D templates, be it type manipulation, code generation or language extension \ldots Most examples are code snippets that were useful to me at one time or another. I hope they will be useful to you too.

\aparte{Contributors welcome!}{Even more than for other parts, I welcome any short and synthetic example of what can be done with templates. Do not hesitate to chime in and push some code in this doc!}

\section{Type Sorcery}\label{typesorcery}

One of the most fundamental use of templates is type sorcery: type creation, type manipulation, etc. D being a statically type language, all of your creations will have a defined type. Sometimes, these can be cumbersome to write or manipulate. Templates can help you in this.

\subsection{Mapping, Filtering and Folding Types}

As we saw in section \ref{tuples}, template tuple parameters can hold type tuples (that's even their original role). Since these can be iterated, indexed or sliced, they are ideal candidates to some standard iteration algorithms. As for ranges, you can map another template on type tuples, filter the types you want to extract or fold (reduce) them into another type.

\aparte{And non-types?}{What about acting on expression tuples? You can do that too. Even though this section is called \emph{Type} Sorcery, all templates here can work on expression tuples too. Do not feel limited.}

\subsubsection{Mapping on Type Tuples}\label{staticmap}

Mapping a type tuple is simply applying another (unary) template on all types of a type tuple. Phobos already defines \DD{staticMap} in \std{typetuple}, but it's a nice exercise to code it again. We want a template that takes another template name (as an \D{alias} parameter), say \DD{Wrapper}, and a typetuple (\DD{T0, T1, T2, ..., Tn}) and returns \DD{Wrapper!T0, Wrapper!T1, Wrapper!T2, ..., Wrapper!Tn}.

\begin{dcode}
template staticMap(alias M, T...)
{
    static if (T.length == 0) // End of sequence
        alias TypeTuple!() staticMap; // stop there
    else
        alias TypeTuple!(M!(T[0]), staticMap!(M, T[1..$])) staticMap;
}
\end{dcode}

We use the auto-flattening of type tuples to aggregate the results into a unique tuple. Notice how indexing and slicing make for a not-so-complicated piece of code.

Even a simple template such as this one can have great uses:

\begin{itemize}
\item Getting rid of all qualifiers in a type list, by mapping \stdanchor{traits}{Unqual} on the types.
\item Generating a huge quantity of types by using a typetuple-returning mapper (see below).
\item Given a bunch of function types, getting their return types or parameter typetuples.
\end{itemize}

\subsubsection{Example: Testing a Function}

The seconde use in the previous section's list can be useful to unit-test a part of your code. Suppose you have a templated function that is supposed to work on any built-in type. You do not need to generate all possible combinations of types. Just use \DD{staticMap} to generate them for you:

\begin{dcode}
/** 
* Given a type T, generates all qualified versions of T
* that you find interesting (eleven versions all in all).
*/
template Qualified(T)
{
    alias TypeTuple!(
                     T, const(T), immutable(T), shared(T),
                     T[],const(T)[],immutable(T)[], shared(T)[], 
                     const(T[]), immutable(T[]), shared(T[])
                    ) Qualified;
}

// All 16 built-in types you're interested in.
alias TypeTuple!(
                 bool,
                 ubyte,byte,
                 ushort,short,
                 uint,int,
                 ulong,long,
                 float,double,real,
                 char,wchar,dchar
                ) ValueTypes;

// Bang, 11*16 types generated.
alias staticMap!(Qualified,ValueTypes) QualifiedTypes;

// If you're really a pervert (note that there will be duplicates)
alias staticMap!(Qualified, QualifiedTypes) DoublyQualifiedTypes;
\end{dcode}

Now, if your function is supposed to work on all the generated qualified types, just test it:

\begin{dcode}
void myFun(T)(T t) { ... }

/* Here we generate the qualified types, see above */
(...) 
temp
late test(alias fun)
{
    void on(T...)()
    {
        foreach(Type; T)
            static if (!__traits(compiles, fun(Type.init)))
                pragma(msg, "Bad testing combination: " 
                          ~ fun.stringof ~ " and " ~ Type.stringof);
    }
}
   
unittest 
{
    test!(myFun).on!(QualifiedTypes);
}
\end{dcode}

\subsubsection{Filtering Type Tuples}\label{staticfilter}

You can search for and extract some types from a tuple, using a predicate to chose which type (or more generally, which tuple element) you want to keep. A predicate in this particular case means 'a template that, when given a type as argument, will return either \D{true} or \D{false}'. The test done on the tuple element can be as complicated as you want, particularly using \D{is}\DD{()} expressions (see \autoref{isexpression}).

That gives us the following code:

\begin{dcode}
template staticFilter(alias Pred, T...)
{
    static if (T.length == 0) // End of sequence
        alias TypeTuple!() staticFilter;
    else static if (Pred!(T[0])
        alias TypeTuple!(T[0], staticFilter!(Pred, T[1..$])) staticFilter;
    else
        alias TypeTuple!(      staticFilter!(Pred, T[1..$])) staticFilter;
}
\end{dcode}

Using \DD{staticFilter} is quite simple. Let's get integral types from a tuple, by way of \stdanchor{traits}{isIntegral}:

\begin{dcode}
alias TypeTuple!(int, double, float, string, byte, bool, float, void) Types;

alias staticFilter!(isIntegral, Types) OnlyIntegrals;

static assert(is(OnlyIntegrals == TypeTuple!(int, byte, bool)));
\end{dcode}

But that is, admittedly, pretty boring stuff. Though useful from time to time, it's quite rare for someone to be given a pure type tuple like this. A much more common use for the likes of \DD{staticFilter} is when creating complex types.

\subsubsection{Example: building a \DD{Graph}}

As a first example, imagine you have a \DD{Graph(Node, Edge)} struct, templated on the nodes (vertice) and edges types (themselves templated). When you create a \DD{Graph} with a factory function (\ref{factory}), it would be nice to be able to mix nodes and edges in a natural way. That is, given \DD{graph}, \DD{node} and \DD{edge} functions that do the obvious thing, you want to autorize calls like:

\begin{dcode}
/** 
* Automatically creates a graph 
*   - with four nodes labelled "A", "B", "C", "D", holding a double, 
*   - with nodes linking "A" to "B", "D" to "A" and "D" to "C".
*/
auto g = graph(node("A", 3.14159), node("B", 1.0), 
               edge("A","B"),
               node("C", 2.71828), node("D", 0.0), 
               edge("D","A"), edge("D", "C"));
\end{dcode}

This allows the user building her \DD{Graph} to create nodes and edges between these nodes in a natural way (as opposed to, say, batch-building all nodes and then adding edges between them). But, as a library writer, that means your \DD{graph} factory function has the following signature:

\begin{dcode}
auto graph(NodesOrEdges...)(NodesOrEdges args) 
if (/* sanity check test on NodesOrEdges */)
\end{dcode}

Both the sanity check performed by the template constraint (\ref{constraints}) and the building code inside \DD{graph} can be quite complicated. \DD{staticFilter} helps by separating the arguments between nodes and edges. Without extending this example too much, say we have at our disposal the following predicate templates:

\begin{dcode}
template isNode(N) {/* true iff N is a Node!(LabelType, ValueType)*/}
template isEdge(E) {/* true iff E is an Edge!(LabelType)*/}

template isNodeOrEdge(T)
{
    static if (isNode!T || isEdge!T)
        enum isNodeOrEdge = true;
    else
        enum isNodeOrEdge = false;
}
\end{dcode}

And let's suppose also all \emph{bona fide} \DD{Node}s and \DD{Edge}s have  \DD{.LabelType} and \DD{.ValueType} members exposing their inner types (as shown in \autoref{inneralias}).

Then, getting all nodes and edges is easy:
\begin{dcode}
alias staticFilter!(isNode, NodesOrEdges) Nodes;
alias staticFilter!(isEdge, NodesOrEdges) Edges;
\end{dcode}

This is where things get interesting: obtaining the edges and nodes types is just a first building block. Now \DD{graph} must check at a minimum the following elements:

\begin{enumerate}
\item All arguments must be nodes or edges.
\item Is there at least \emph{one} node in the list?
\item If yes, do all nodes have the same \DD{LabelType} and the same \DD{ValueType}, or, at least, is there a common type between all the labels' types and another one for the values stored in the nodes?
\item Do edges' \DD{LabelTypes} have a common type? (Note that there can be zero edges).
\item Do the edges labels have the correct type to refer to the provided nodes?
\end{enumerate}

Note that \emph{all} these checks are done only on types and thus can be done at compile-time, thereby ensuring a pretty solid static check on the graph built. What cannot be done in this way is verifying during compilation that edges do indeed refer to existing nodes.

Let's use what we have seen until now to create the \DD{GraphCheck}\label{graphcheck} template, before seeing another \DD{staticFilter} example:

\begin{dcode}
import std.traits: CommonType;

template GraphCheck(NodesOrEdges...)
{
    enum GraphCheck = GraphCheckImpl!(NodesOrEdges).result;
}

template GraphCheckImpl(NodesOrEdges...)
{
    alias staticFilter!(isNode, NodesOrEdges) Nodes;
    alias staticFilter!(isEdge, NodesOrEdges) Edges;
    
    // 1. All arguments must be nodes or edges
    static if (Nodes.length + Edges.length != NodesOrEdges.length)
    static assert(0, "Some args are not nodes or edges.");
    
    // 2. There must be at least one node
    static if (Nodes.length == 0)
    static assert(0, "You must provide at least one node.");
    
    // 3. Is there a common type for the nodes' labels and values?
    // First step: extracting labels and values
    template GetLabel(T) if (isNode!T || isEdge!T)
    {
        alias T.LabelType GetLabel;
    }
    
    template GetValue(T) if (isNode!T)
    {
        alias T.ValueType GetValue;
    }

    alias staticMap!(GetLabel, Nodes) NodesLabels;
    alias staticMap!(GetValue, Nodes) NodesValues; 
    
    static if (is(CommonType!(NodesLabels) == void)) // no common type
    static assert(0, "The nodes do not have all the same label type.");
    
    static if (is(CommonType!(NodesValues) == void))
    static assert(0, "The nodes do not have all the same value type.");

    // 4. Same for edges
    alias staticMap!(GetLabel, Edges) EdgesLabels;  
    
    static if (is(CommonType!(EdgesLabels) == void))
    static assert(0, "The edges do not have all the same label type.");
        
    // 5. Edges - Node compatibility
    static if(!is(CommonType!NodesLabels == CommonType!EdgesLabels))
        static assert(0, "Nodes and edges do not have the same label type.");
    
    enum result = true;
}    
\end{dcode}

This is one huge template, but \DD{staticFilter} sits square in the middle and greatly simplifies the code. Now, \DD{graph} signature is simply:

\begin{dcode}
auto graph(NodesOrEdges...)(NodesOrEdges args) if (GraphCheck!NodesOrEdges)
{ ... }
\end{dcode}

\unfinished{The second example will be one code generating a struct, with string literal and type parameters.}

\subsubsection{Folding Type Tuples}\label{staticreduce}

\TODO{Examples to give: biggest type in the lot, sorting types?}

\subsection{Zipping Types, Interleaving Types, Crossing Types}

\TODO{Determine if this subsection is really useful. Is there any short and telling example?}

\subsubsection{Interleaving Types}\label{interleavingtypes}

\begin{dcode}
/**
 * Given (T0, T1, T2, ..., Tn) and (U0, U1, ..., Um) will returns
 * the interleaving of the first part with the second part: 
 *
 * (T0, U0, T1, U1, ...
 *
 * If one of the inputs is shorter than the other, 
 * the longer part is put at the end of the interleaving.
 */
template Interleave(First...)
{
    template With(Second...)
    {
	static if (First.length == 0)
	    alias Second With;
	else static if (Second.length == 0)
	    alias First With;
	else
	    alias TypeTuple!( First[0], Second[0]
	                    , Interleave!(First[1..$]).With!(Second[1..$])) 
             With;
    }
}

\end{dcode}

\subsection{Annotating Types}\label{annotatingtypes}

\unfinished{The idea is to wrap values in a template adding some meta data. Ideally, I'd like to get things like the following code to work:}

\begin{dcode}
auto arr = [0,1,2,3,4]; // Array of ints
auto arr2 = sorted(arr); // Now, we know it's sorted
auto arr3 = positive(arr2); // Sorted *and* all elements are positive
\end{dcode}

Or, more generally:

\begin{dcode}
auto arr = [0,1,2,3,4]; // Array of ints
auto arr2 = annotate!("sorted", (a,b) => a<b)(arr);
auto arr3 = annotate!("positive")(arr2);

assert("positive" in arr3.properties);
assert(arr3.Properties == TypeTuple!( Property!("sorted", (a,b) => a < b)
                                    , Property!("positive")));

// the wrapped value is still there:             
auto arr4 = array(filter!((a) => a%2==0))(arr3);
// getting rid of some properties
auto arr5 = arr3.discardProperty!"positive"; 
assert(arr5.Properties == TypeTuple!(Property!("sorted", (a,b) => a < b)));

auto arr6 = annotate!("negative")([-4, -3, -2, -1]);
auto arr7 = annotate!("sorted", (a,b) => a<b)(arr6);

assert(arr3.property!"sorted" == arr7.property!"sorted"); // same predicate                                    
\end{dcode}

\section{Tuples as Sequences}\label{tuplesassequences}

\subsection{Mapping on Tuples}\label{mappingontuples}

\subsection{Filtering Tuples}\label{filteringtuples}

\begin{dcode}
(1, "abc", 2, "def", 3.14)
->
((1,2),("abc","def"),(3,14))
\end{dcode}


\section{Fun With Functions}\label{funwithfunctions}

This section will present some templated wrappers around functions, to provide some additional usefulness. It's not part of \autoref{functiontemplates} because it uses struct templates and it's not part of \autoref{structtemplates} because the wrapper struct is not the main focus of attention.

\subsection{Memoizing a Function} \label{memoizing}

When a function does long calculations, it might be efficient to store the computed results in an external structure and to query this structure for the result instead of calling the function again. This is called \emph{memoizing} (not \emph{memorizing}\ldots) and this sectino will show how to use a template to have some memoizing fun.

The previously-seen results are stored in an associative array, indexed on tuples of arguments. To get a function return type or parameter type tuple, just use Phobos' \stdanchor{traits}{ReturnType} and \stdanchor{traits}{ParameterTypeTuple}, which are templates that accept function \emph{names} or types.

\index{struct template!memoize@\DD{memoize}}
\index{function templates!wrapping a function!memoize@\DD{memoize}}
\index{template!parameters!alias}
\begin{dcode}
struct Memoize(alias fun)
{
    alias ReturnType!fun RT;
    alias ParameterTypeTuple!fun PTT;
    RT[Tuple!(PTT)] memo; // stores the result, indexed by arguments.

    RT opCall(PTT args)
    {
        if (tuple(args) in memo)      // Have we already seen these args?
        {
            return memo[tuple(args)]; // if yes, use the stored result
        }
        else // if not, compute the result and store it.
        {
            RT result = fun(args);
            memo[tuple(args)] == result;
            return result;
        }
    }
}

Memoize!fun memoize(alias fun)()
{
    return Memoize!fun();
}
\end{dcode}

Usage is very simple:

\begin{dcode}
int veryLongCalc(int i double d, string s) { ... }

auto vlcMemo = memoize!(veryLongCalc);

// calculate veryLongCalc(1, 3.14, "abc")
// takes minutes!
int res1 = vlcMemo(1, 3.14, "abc"); 
int res2 = vlcMemo(2, 2.718, "def");// minutes again!
int res3 = vlcMemo(1, 3.14, "abc"); // a few ms to get res3
\end{dcode}

The above code is trivial and could be optimized in many ways. Mostly, a real memoizing template should also modify its behavior with storing policies. For example:

\begin{itemize}
\item No-limit or limited size store? 
\item In case of limited-size store: how to define the limit and what should be the eviction policy?
\begin{itemize}
\item First-in/First-out memo?
\item Least recenly used memo?
\item Least used?
\item Time-to-live?
\item Discard all and flush the store?
\item Discard only a fraction?
\item Stop memoizing?
\end{itemize}
\end{itemize}

The last X results could be stored in a queue: each time a result is pushed into the associative array, push the arguments tuples in the queue. Once you reach the maximum store limit, discard the oldest one or (for example) half the stored values.

Here is a possible small implementation. It makes for a nice example of enabling/disabling code with \D{static if} and \D{enum}-based policies. Note that I use D dynamic arrays as a primitive queue. A real queue could probably be more efficient, but there isn't one in the standard library as of this writing.

\index{struct template!memoize@\DD{memoize}}
\index{function templates!wrapping a function!memoize@\DD{memoize}}
\index{template!parameters!alias}
\index{enabling/disabling code}
\index{enum-based policy@\D{enum}-based policy}
\index{idiom!enabling/disabling code}
\index{idiom!policy}
\begin{dcode}
enum Storing { 
    always,  // there is no tomorrow
    maximum  // sustainable growth
}

enum Discarding { 
    oldest,   // only discard the oldest result
    fraction, // discard a fraction (0.5 == 50%)
    all       // burn, burn!
}

struct Memoize(alias fun, 
               Storing storing,
               Discarding discarding)
{
    alias ReturnType!fun RT;
    alias ParameterTypeTuple!fun PTT;

    static if (storing == Storing.maximum)
    {
        Tuple!(PTT)[] argsQueue;
        size_t maxNumStored;
    }
    
    static if (discarding == Discarding.fraction)
        float fraction;

    RT[Tuple!(PTT)] memo; // stores the result, indexed by arguments.
    
    RT opCall(PTT args) 
    {
        if (tuple(args) in memo)      // Have we already seen these args?
        {
            return memo[tuple(args)]; // if yes, use the stored result
        }
        else                          // if not,
        {                             
            static if (storing == Storing.always)
            {
                RT result = fun(args);// compute the result and store it.
                memo[tuple(args)] = result;
                return result;
            }
            else // Storing.maximum
            {
                if (argsQueue.length >= maxNumStored)
                {
                    static if (discarding == Discarding.oldest)
                    {
                        memo.remove(argsQueue[0]);
                        argsQueue = argsQueue[1..$];
                        writeln("Discarding oldest.");
                    }
                    else static if (discarding == Discarding.fraction)
                    {
                        auto num = to!size_t(argsQueue.length * fraction);
                        foreach(elem; argsQueue[0..num])
                            memo.remove(elem);
                        argsQueue = argsQueue[num..$];
                        writeln("Discarding fraction.");
                    }
                    else static if (discarding == Discarding.all)
                    {
                        memo = null;
                        argsQueue.length = 0;
                        writeln("Discarding all.");
                    }
                }
                
                RT result = fun(args);// compute the result and store it.
                memo[tuple(args)] = result;
                argsQueue ~= tuple(args);
                return result;            
            }
        }
    }
}
\end{dcode}

And a few factory function to help creating those \DD{Memoize} structs:

\begin{dcode}
// No runtime arg -> always store
Memoize!(fun, Storing.always, Discarding.all)
memoize(alias fun)()
{
    Memoize!(fun, 
             Storing.always, 
             Discarding.all) result;
    return result;
}

// One runtime size_t arg -> maximum store / discarding all
Memoize!(fun, Storing.maximum, Discarding.all)
memoize(alias fun)(size_t max)
{
    Memoize!(fun, 
             Storing.maximum, 
             Discarding.all) result;
    result.maxNumStored = max;
    return result;
}

// Two runtime args (size_t, double) -> maximum store / discarding a fraction
Memoize!(fun, Storing.maximum, Discarding.fraction)
memoize(alias fun)(size_t max, double fraction)
{
    Memoize!(fun, 
             Storing.maximum, 
             Discarding.fraction) result;
    result.maxNumStored = max;
    result.fraction = fraction;
    return result;
}

// One compile-time argument (discarding oldest), one runtime argument (max)
Memoize!(fun, Storing.maximum, discarding)
memoize(alias fun, Discarding discarding = Discarding.oldest)
(size_t max)
{
    Memoize!(fun, 
             Storing.maximum, 
             Discarding.oldest) result;
    result.maxNumStored = max;
    return result;
}
\end{dcode}

Note that, due to the introduction of an \DD{opCall} operator, it's not possible to use a struct literal. We have to first create the struct, then initialize its fields.

Most of the time, the type of runtime arguments is enough to determine what you want as a memoizing/storing behavior. Only for the (rarer?) policy of discarding only the oldest stored result does the user need to indicate it with a template argument:

\begin{dcode}
int veryLongCalc(int i double d, string s) { ... }

// Store the first million results, flush the memo on max
auto vlcMemo1 = memoize!(veryLongCalc)(1_000_000);

// Store the first million results, flush half the memo on max
auto vlcMemo2 = memoize!(veryLongCalc)(1_000_000, 0.5f);

// Store first twenty results, discard only the oldest
auto vlcMemo3 = memoize!(veryLongCalc, Discarding.oldest)(20);
\end{dcode}

\subsection{Currying a Function} \label{currying}

\unfinished{Some explanations would greatly help there.}

Another useful transform on functions is to \emph{curry}\footnote{from Haskell Curry, the guy who formalized the idea.} them: to transform a $n$-args function into $n$ one-parameter functions inside another.

\TODO{Show some example: mapping a range for example.}

\index{static if@\D{static if}!recursion}
\index{static if@\D{static if}!nested}
\index{template!double-decker template!CheckCompatibility.With@\DD{CheckCompatibility.With}}
\begin{dcode}
template CheckCompatibility(T...)
{
    template With(U...)
    {
        static if (U.length != T.length)
            enum With = false;
        else static if  (T.length == 0) // U.length == 0 also
            enum With = true;
        else static if (!is(U[0] : T[0]))
            enum With = false;
        else
            enum With = CheckCompatibility!(T[1..$]).With!(U[1..$]);
    }
}
\end{dcode}

\index{operator!opCall, ()@\DD{opCall}, \DD{()}}
\index{template!parameters!integral value}
\index{template!parameters!alias}
\index{static assert@\D{static assert}}
\begin{dcode}
struct Curry(alias fun, int index = 0)
{
    alias ReturnType!fun RT;
    alias ParameterTypeTuple!fun PTT;
    PTT args;

    auto opCall(V...)(V values)
        if (V.length > 0
         && V.length + index <= PTT.length)
    {
        // Is fun directly callable with the provided arguments?
        static if (__traits(compiles, fun(args[0..index], values)))
            return fun(args[0..index], values);
        // If not, the new args will be stored. We check their types.
        else static if (!CheckCompatibility!(PTT[index..index + V.length]).With!(V))
            static assert(0, "curry: bad arguments. Waited for "
                            ~ PTT[index..index + V.length].stringof
                            ~ " but got " ~ V.stringof);
        // not enough args yet. We store them.
        else
        {
            Curry!(fun, index+V.length) c;
            foreach(i,a; args[0..index]) c.args[i] = a;
            foreach(i,v; values) c.args[index+i] = v;
            return c;
        }
    }
}

auto curry(alias fun)()
{
    Curry!(fun,0) c;
    return c;
}
\end{dcode}

\subsection{Juxtaposing functions}\label{juxtapose}

\TODO{See where the code is. It used heavy-duty type manipulation IIRC.}

\section{Relational Algebra}

Inspiration for this example comes from \href{http://david.rothlis.net/d/templates}{This blog article}.

\TODO{Extracting from a tuple: project, select. Also, natural/inner/outer join, cartesian product. And intersection/union/difference. rename!( "oldField", "newField"). Databases are just dynamic arrays of tuples.}.

\section{Fun With Classes and Structs}

\subsection{Class Hierarchy}\label{classhierarchy}

\unfinished{Two things I'll show here: how to get a class parents an how to determine an entire hierarchy of classes in a local scope.}

\subsection{Cloning, sort of}

\TODO{(Elsewhere) creating a class from a struct?}

\subsection{Generic Maker Function}

Like this:

\begin{dcode}
class C
{
    int i, j;
    
    this(int _i) { i = _i; j = _i;}
    this(int _i, int _j) { i = _i; j =_j;}
}

alias make!C makeC;

auto theCs = map!makeC([0,1,2,3,4]);
auto theCs2 = map!makeC(zip([0,1,2,3,4], 
                            [4,3,2,1,0]));
\end{dcode}

\section{Library Typedef}

From Trass3r:

\begin{dcode}
enum Type
{
    Independent,
    Super,
    Sub,
    Parallel,
}

struct Typedef( T, 
                Type type = Type.Sub, 
                T init = T.init, 
                string _f = __FILE__,
                int _l = __LINE__ )
{
    T payload = init;

    static if ( type != Type.Independent )
        this( T value )
        {
            payload = value;
        }

    static if ( type == Type.Sub)
        // typedef int foo; foo f;
        // f.opCast!(t)() == cast(t) f
        T opCast(T)()
        {
            return payload;
        }

    static if ( type == Type.Sub || type == Type.Parallel )
        alias payload this;

    static if ( type == Type.Super )
        typeof( this ) opAssign( T value )
        {
            payload = value;
            return this;
        }
    else static if ( type == Type.Sub )
        @disable void opAssign( T value );
}
\end{dcode}

\section{Emitting Events}

This example template, comprising \DD{Fields} and \DD{Notify}, comes from Andrej Mitrovic. He has be kind enough to allow me to put it there and to give me some explanations for the logic behind this template. He's using it in his experimental GUI library to signal an event.

\begin{dcode}
template isSomeStringLiteral(alias a)
{
    enum isSomeStringLiteral = isSomeString!(typeof(a));
}

mixin template Fields(T, fields...) 
    if (allSatisfy!(isSomeStringLiteral, fields))
{
    alias typeof(this) This;

    static string __makeFields(T, fields...)()
    {
        string res;
        foreach(field; fields) res ~= T.stringof~ " " ~ field ~ ";\n";
        return res;
    }

    static string __makeOpBinaryFields(string op, fields...)()
    {
        string res;
        foreach(field; fields) 
            res ~= "res." ~ field 
                 ~ " = this." ~ field ~ op ~ " rhs." ~ field ~ ";\n";
        return res;
    }

    mixin(__makeFields!(T, fields)());

    This opBinary(string op)(This rhs)
    {
        This res;
        mixin(__makeOpBinaryFields!(op, fields)());
        return res;
    }

    void opOpAssign(string op)(This rhs)
    {
        mixin("this = this " ~ op ~ " rhs;");
    }                
}
\end{dcode}

The user mix it in its own types:

\begin{dcode}
struct Point {
    mixin Fields!(int, "x", "y", "z", "w");
}

struct Size {
    mixin Fields!(int, "width", "height");
}
\end{dcode}

This goes hand in hand with the \DD{Notify} struct template:

\begin{dcode}
struct Notify(T)
{
    alias void delegate(ref T) OnEventFunc;
    OnEventFunc onEvent;

    void init(OnEventFunc func) {
        onEvent = func;
    }

    string toString()
    {
        return raw.toString;
    }

    auto opEquals(T)(T rhs)
    {
        return rhs == rhs;
    }

    void opAssign(T)(T rhs)
    {
        if (rhs == raw)
            return;  // avoid infinite loops
        
        // temp used for ref
        auto temp = rhs;  
        onEvent(temp);
    }

    auto opBinary(string op, T)(T rhs)
    {
        mixin("return raw " ~ op ~ " rhs;");
    }

    void opOpAssign(string op, T)(T rhs)
    {
        // temp used for ref
        mixin("auto temp = raw " ~ op ~ " rhs;");  

        if (temp == raw)
            return;  // avoid infinite loops

        onEvent(temp);
    }

    public T raw;  // raw access when we don't want to invoke event()
    alias raw this;
}
\end{dcode}

Which you mix in classes you want to notify any changes to their internal state:

\begin{dcode}
class Widget 
{
    this()
    {
        point.init((Point pt) { writefln("changed point to %s", pt); });
        size.init((Size sz)   { writefln("changed size to %s", sz); });
    }

    Notify!Point point;
    Notify!Size size;
}
\end{dcode}

For example, a user might change the point (position) field of a widget via: 

\begin{dcode}
Point moveBy = Point(10, 0); widget.point += moveBy;}. 
\end{dcode}

This doesn't modify the field yet, but only triggers \DD{onEvent(moveBy)}, which in turn emits a signal containing the \DD{Widget} reference and the requested position \DD{doMove.emit(this, moveBy)}. This gets processed by a chain of an arbitrary number of listeners. These listeners take \DD{moveBy} by reference and this comes in handy when e.g. a \DD{Widget} is part of a \DD{Layout}. The \DD{Layout} simply adds itself to the chain of listeners and edits the ref argument if it wants to, or even returns \D{false} to completely deny any changes to a field.

This allows for some great flexibility. For example, say a user subclasses from \DD{Widget} (let's call it \DD{Child}), and overrides \DD{onMove()} of the widget to limit it to the position of:

\begin{dcode}
min: Point(10, 10) (top-left)
max: Point(100, 100) (bottom-right)
\end{dcode}

This \DD{Widget} has a parent \DD{Widget} (call it \DD{Parent}), which has a layout set. The layout might allow any child \DD{Widget}s of the \DD{Parent} to only be set between the following positions:

\begin{dcode}
min: Point(20, 20)
max: Point(80, 80)
\end{dcode}

Additionally the layout might take a child's size into account so the \DD{Widget} never overflows the \DD{min} and \DD{max} points of the layout. If this \DD{Widget} was at \DD{Point(20, 20)} and had \DD{Size(50, 50)} it means the layout will limit the \DD{Wid\-get}'s minimum and maximum points to:

\begin{dcode}
min: Point(20, 20)
max: Point(30, 30)
\end{dcode}

When the \DD{Widget} is at \DD{Point(30, 30)} its bottom-right point will be \DD{Point(80, 80)}, which is the maximum bottom-right point the layout has set. The layout won't allow the \DD{Widget} to be at position \DD{Point(10, 10)} either, even though \DD{Widget}'s \DD{onMove} method allows it.

So if the user tries to call:

\begin{dcode}
child.point = Point(120, 120);
\end{dcode}

First, \DD{Child}'s \DD{onMove} is the first listener of some \DD{doMove} signal. It will modify the ref argument and set it to \DD{Point(100, 100)} as the user coded it that way. Then, the layout will modify it to \DD{Point(30, 30)} since it takes \DD{Widget}'s size into account so it doesn't overflow.

There could be any number of listeners, and you could add a listener to any position in the chain of events (maybe you want to intercept and modify the argument before it reaches \DD{Parent}'s layout if you want to set temporary limits to a \DD{Widget}'s position).

Finally, there is always one last listener. This one is an internal function that actually modifies the \DD{.raw} field, and calls into internal painting and blitting functions to make the \DD{Widget} appear into its new position. Also, any listener can return \D{false} to break further processing of events and deny modifying the field.

Notice that assignments never happen, external code has to use the \DD{.raw} field to actually modify the internal payload, which avoids calling \DD{onEvent()}.

\section{Fields}

From Jacob's Carlborg \href{https://github.com/jacob-carlborg/orange}{Orange} serialization library:

\begin{dcode}
/**
 * Evaluates to an array of strings containing 
 * the names of the fields in the given type
 */
template fieldsOf (T)
{
	const fieldsOf = fieldsOfImpl!(T, 0);
}

/**
 * Implementation for fieldsOf
 * 
 * Returns: an array of strings containing the names of the fields in the given type
 */
template fieldsOfImpl (T, size_t i)
{
    static if (T.tupleof.length == 0)
        enum fieldsOfImpl = [""];

    else static if (T.tupleof.length - 1 == i)
        enum fieldsOfImpl = [T.tupleof[i].stringof[1 + T.stringof.length + 2 .. $]];

    else
        enum fieldsOfImpl = T.tupleof[i].stringof[1 + T.stringof.length + 2 .. $] ~ fieldsOfImpl!(T, i + 1);
}
\end{dcode}

\section{Extending an enum}

From Simen Kjaeraas (posted on the D newsgroup).

\begin{dcode}
string EnumDefAsString(T)() if (is(T == enum)) {
    string result = "";
    foreach (e; __traits(allMembers, T))
        result ~= e ~ " = T." ~ e ~ ",";
    return result;
}

template ExtendEnum(T, string s) 
    if (is(T == enum) &&
        is(typeof({mixin("enum a{"~s~"}");}))) 
{
mixin(
    "enum ExtendEnum {"
   ~ EnumDefAsString!T() ~ s
   ~ "}");
}

enum bar 
{
    a = 1,
    b = 7,
    c = 19
}

import std.typetuple;

alias ExtendEnum!(bar, q{ // Usage example here.
      d = 25
    }) bar2;

foreach (i, e; __traits(allMembers, bar2)) {
    static assert( e == TypeTuple!("a", "b", "c", "d")[i] );
}

assert( bar2.a == bar.a );
assert( bar2.b == bar.b );
assert( bar2.c == bar.c );
assert( bar2.d == 25 );

static assert(!is(typeof( ExtendEnum!(int, "a"))));
static assert(!is(typeof( ExtendEnum!(bar, "25"))));
\end{dcode}

\section{Static Switching} \label{examples:staticswitch}

\TODO{What, no compile-time switch? Let's create one}.
Example of: tuples, type filtering (in constraints), recursion, etc.

\begin{dcode}
template staticSwitch(List...) // List[0] is the value commanding the switching
                               // It can be a type or a symbol.
{
    static if (List.length == 1) // No slot left: error
        static assert(0, "StaticSwitch: no match for " ~ List[0].stringof);
    else static if (List.length == 2) // One slot left: default case
        enum staticSwitch = List[1];
    else static if (is(List[0] == List[1]) // Comparison on types
                || (  !is(List[0])         // Comparison on values
                   && !is(List[1])
                   && is(typeof(List[0] == List[1]))
                   && (List[0] == List[1])))
        enum staticSwitch = List[2];
    else
        enum staticSwitch = staticSwitch!(List[0], List[3..$]);
}
\end{dcode}

\section{Generic Structures}

\subsection{Gobble}\label{gobble}

\begin{dcode}

struct Gobbler(T...)
{
    T store;
    Gobbler!(T, string,U) opBinary(string op, U)(U u) if (op == "~")
    {
        return Gobbler!(T,string, U)(store, op, u);
    }
}

Gobbler!() gobble() { return Gobbler!()();}
\end{dcode}

\subsection{A Polymorphic Tree}\label{polymorphictree}

\subsection{Polymorphic Association Lists}\label{associationlists}

Usage: a bit like Lua tables: structs, classes (you can put anonymous functions in them?),  namespaces.
Also, maybe to add metadata to a type?

\begin{dcode}
template Half(T...)
{
    static if (T.length <= 1)
        alias TypeTuple!() Half;
    else
        alias TypeTuple!(T[0], Half!(T[2..$])) Half;
}

struct AList(T...)
{
    static if (T.length >= 2 && T.length % 2 == 0)
        alias Half!T Keys;
    else static if (T.length >= 2 && T.length % 2 == 1)
        alias Half!(T[0..$-1]) Keys;
    else
        alias TypeTuple!() Keys;

    static if (T.length >= 2)
        alias Half!(T[1..$]) Values;
    else
        alias TypeTuple!() Values;

    template at(alias a)
    {
        static if ((staticIndexOf!(a, Keys) == -1) && (T.length % 2 == 1)) // key not found, but default value present
            enum at = T[$-1]; // default value
        else static if ((staticIndexOf!(a, Keys) == -1) && (T.length % 2 == 0))
            static assert(0, "AList: no key equal to " ~ a.stringof);
        else //static if (Keys[staticIndexOf!(a, Keys)] == a)
            enum at = Values[staticIndexOf!(a, Keys)];
    }
}

alias AList!( 1,     "abc"
            , 2,     'd'
            , 3,     "def"
            , "foo", 3.14
            ,        "Default") al;

writeln("Keys: ", al.Keys);
writeln("Values: ", al.Values);
writeln("at!1: ", al.at!(1));
writeln("at!2: ", al.at!(2));
writeln("at!\"foo\": ", al.at!("foo"));
writeln("Default: ", al.at!4);
\end{dcode}

\subsection{Expression Templates}\label{expressiontemplates}



\section{Statically-Checked Writeln}\label{staticallycheckedwriteln}

\TODO{As an intro to compile-time parsing, for a limited (!) domain-specific language.}

\section{Extending a Class}\label{extendingaclass}

There is regularly a wish in the D community for something called Universal Function Call Syntax (UFCS):\index{syntax!Universal Function Call Syntax}\index{UFCS} the automatic transformation of \DD{a.foo(b)} into \DD{foo(a,b)} when \DD{a} has no member called \DD{foo} and there \emph{is} a free function called \DD{foo} in the local scope\index{scope!local scope}. This already works for arrays\index{arrays!UFCS} (hence, for strings) but not for other types.

There is no way to get that in D for built-in types except by hacking the compiler, but for user-defined types, you can call templates to the rescue.

\DD{opDispatch} can be used to forward to an external free function. A call \D{this}\DD{.method(a,b)} becomes \DD{method(}\D{this}\DD{,a,b)}.

\begin{dcode}
mixin template Forwarder
{
    auto opDispatch(string name, Args...)(Args args)
    {
        mixin("return " ~ name ~ "(args);");
    }
}
\end{dcode}

In D, a void \D{return} clause is legal: 

\begin{dcode}
return;
// or return void;
\end{dcode}

So if \DD{name(}\D{this}\DD{,a,b)} is a \D{void}-returning function, all is OK.

The main limitation of this trick is that it doesn't work across modules boundaries. Too bad.

\section{Pattern Matching With Functions}

\unfinished{The idea is to group a bunch of templates together and use their pattern matching ability. Maybe to be put in \autoref{functiontemplates}?}

\section{Generating a Switch for Tuples}
Case 0:, etc.

Or more generaly, the idea to craft specific runtime code given compile-time information.
See also \autoref{sortingnetworks}.
