import std.algorithm, std.array, std.conv,
std.exception, std.file, std.format,
std.path, std.process, std.stdio, std.range, std.regex;

immutable string samplesDir = "code";
enum modName = ctRegex!("module (.+?);");

void main(string[] args)
{
    //if (!exists(samplesDir)) mkdir(samplesDir);
    auto compilationResults = File("results.txt", "w");
    auto texFiles = filter!`endsWith(a.name,".tex")`(dirEntries("..",SpanMode.shallow));
    
    string[] fileNames;
    string[][string] sampleNames;
    bool[string] gotMain;
    int[string] anonymousSamples;
    
    foreach(entry; texFiles)
    { 
        auto fileName = baseName(entry.name);
        fileNames ~= fileName;
        anonymousSamples[fileName] = 0;
        
        auto file = File("../" ~ fileName, "r");
        
        bool inCode;
        string accumulator;
        string sampleName;
                
        foreach(line; file.byLine) // KeepTerminator.yes doesn't work?
        {
            if (line.startsWith("\\begin{dcode}") || line.startsWith("\\begin{ndcode}")) 
            {
                inCode = true;
                continue;
            }

            if (inCode && line.startsWith("module "))
            {
                auto m = match(line, modName);
                sampleName = to!string(m.captures[1]);
            }
            
            if (inCode && line.startsWith("void main()") && sampleName != "") 
                gotMain[sampleName~".d"] = true;
            
            if (inCode && (line.startsWith("\\end{dcode}") || line.startsWith("\\end{ndcode}")) )
            {
                if (sampleName.length)
                {
                    auto sampleFile = File(sampleName ~ ".d", "w");
                    sampleFile.write(accumulator);
                    sampleFile.close();
                    sampleNames[fileName] ~= (sampleName~".d");
                    if ((sampleName~".d") !in gotMain) 
                        gotMain[sampleName~".d"] = false;
                }
                else
                {
                    anonymousSamples[fileName]++;
                }

                inCode = false;
                accumulator = "";
                sampleName = "";
            }
            
            if (inCode) accumulator ~= line ~ "\n";
        }
    }
        
    // Now we have all samples extracted from all files. Let's compile them.
    
    // Non, attention entre les modules et les samples, je suis en train de confondre.
    // Il faudra probablement un tableau associatif
    foreach(fileName; fileNames)
    {
        compilationResults.write("\n************", fileName, " **************************\n");
        int named;
        if (fileName in sampleNames)
        {
            named = sampleNames[fileName].length;
            compilationResults.write("Found " ~ to!string(named) ~ " named samples.\n");
        
            foreach(sampleName; sampleNames[fileName])
            {
                int compilationResult;
                    
                if (sampleName in gotMain && gotMain[sampleName]) //got main
                    compilationResult = system("rdmd -w -unittest " ~ sampleName);
                else
                    compilationResult = system("rdmd --main -w -unittest " ~ sampleName);
                
                if (compilationResult == 0) // success
                {
                    if (!sampleName.endsWith("_error.d"))
                        compilationResults.write(sampleName ~ ": OK\n");
                    else
                        compilationResults.write(sampleName ~ ": *** ERROR *** (compiled OK, but should fail)\n");
                }
                else // failure
                {
                    if (sampleName.endsWith("_error.d"))
                        compilationResults.write(sampleName ~ ": OK (fail as expected).\n");
                    else
                        compilationResults.write(sampleName ~ ":  *** ERROR! ***\n");
                    
                }
            }
        }
        else
        {
            compilationResults.write("Found no named sample.");
            named = 0;
        }
    
        compilationResults.write("\n");
        compilationResults.write("Found " ~ to!string(anonymousSamples[fileName]) ~ " anonymous samples (no compilation attempted).\n");
        compilationResults.write("Total of " ~ to!string(anonymousSamples[fileName]+named) ~ " samples found.\n");
        compilationResults.write("********************************************************\n\n");
            }
    
    // removing .deps generated by rdmd
    auto deps = filter!`endsWith(a.name,".deps")`(dirEntries(".",SpanMode.shallow));
    foreach(dep; deps)
        system("rm " ~ dep.name);
}