\newpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Around Templates: Other Compile-Time Tools}\label{around}

There is more to compile-time metaprogramming in D than \emph{just} templates. This part will describe the most common tools: string mixins (\ref{stringmixins}), compile-time function evaluation (\ref{ctfe}) and \D{\_\_traits} (\ref{traits}), as seen in relation with templates. For the good news is: they are all interoperable. String mixins are wonderful to inject code in your templates, compile-time-evaluable functions can act as template parameters and can be templated. And, best of best, templated compile-time functions can return strings which can in turn be mixed-in\ldots in your templates. Come and see, it's fun!

\section{String Mixins} \label{stringmixins}

String mixins\index{string mixins} put D code were they are called, just before compilation. Once injected, the code is \emph{bona fide} D code, like any other. Code is manipulated as strings, hence the name.

\subsection{Syntax}\label{stringmixinssyntax}

The syntax is slightly different from mixin templates (\ref{mixintemplates}):

\index{syntax!string mixins}
\begin{dcode}
mixin("some code as a string");
\end{dcode}

You must take care not to forget the parenthesis. String mixins are a purely compile-time tool, so the string must also be determined at compile-time.

\subsection{Mixing Code In, With Templates}\label{stringmixinsandtemplates}

Of course, just injecting predefined code is a bit boring:

\index{example!string mixins}
\begin{dcode}
mixin("int i = 3;"); // Do not forget the two semicolons
                     // one for the mixed-in code,
                     // one for the mixin() call.
i++;
assert(i == 4);
\end{dcode}

There is no interest in that compared to directly writing standard D code. The fun begins with D powerful constant folding ability: in D, strings can be concatenated at compile-time.\index{compile-time!string concatenation} That's where string mixins meet templates: templates can produce strings at compile-time and can get strings as parameters. You alreday saw that in section \ref{operatoroverloading} on operator overloading and section \ref{opdispatch} on \DD{opDispatch}, since I couldn't help doing a bit of foreshadowing.

Now, imagine for example wanting a template that generates structs for you. You want to be able to name the structs as you wish. Say we would like the usage to look like that:

\begin{dcode}
module mine;
import named;

mixin(Named!"First");  // creates struct First { ... }
mixin(Named!"Second"); // and struct Second { ... }

First f1, f2;
Second s1;

assert(is( typeof(s1) == mine.First));
\end{dcode}

Here comes the generating code:

\index{example!string mixins}
\begin{dcode}
module named;

template Named(string name)
{
    enum string Named = "struct " ~ name ~ " { "
                      ~ "/+ some code +/"
                      ~ " }";
}

/* For example, name == "First" ->
   struct First { /+ some code +/ }
*/
\end{dcode}

In this case, the string is assembled inside the template during instantiation,  exposed through the eponymous trick\index{eponymous trick!string mixins} and then mixed in where you want it. Note that the string is generated in the module containing \DD{Named}, but that \DD{First} and \DD{Second} are defined exactly where the \D{mixin}\DD{()} call is. If you use the mixin in different modules, this will define as many different structs, all named the same way. This might be exactly what you want, or not.

To get the same struct in different modules, the code must be organized a bit differently: the structs must be generated in the template module (for example):

\index{example!string mixins}
\begin{dcode}
module named;

template Named(string name)
{
    alias NamedImpl!(name).result Named;
}

template NamedImpl(string name)
{    
    enum string Named = "struct " ~ name ~ " { "
                      ~ "/+ some code +/"
                      ~ " }";
    mixin(Named);
    mixin("alias " ~ name ~ " result;");
}
\end{dcode}

\begin{dcode}
module mine;
import named;

named!"First" f1, f2;
named!"Second" s1;
\end{dcode}

Usage is a different, as you can see. In this case, \DD{First} is generated inside \DD{NamedImpl} and exposed through an alias (this particular alias statement is itself generated by a string mixin). In fact, the entire code could be put in the mixin:

\begin{dcode}
module named;

template Named(string name)
{
    alias NamedImpl!(name).result Named;
}

template NamedImpl(string name)
{
mixin("struct " ~ name ~ " {"
                ~ "/* some code */"
                ~ " }\n"
   ~ "alias " ~ name ~ " result;");
}
\end{dcode}

Here is an example using the ternary \DD{?:} operator to do some compile-time selection of code, similar to what can be done with \D{static if} (\ref{staticif}):

\index{example!string mixins}
\begin{dcode}
enum GetSet { no, yes}

struct S(GetSet getset = GetSet.no, T)
{
    enum priv = "private T value;\n"
               ~ "T get() @property { return value;}\n"
               ~ "void set(T _value) { value = _value;}";

    enum pub = "T value;";

    mixin( (getset == GetSet.yes) ? priv : pub);
}

S!(GetSet.yes, int) gs;

/* Generates:

struct S!(GetSet.yes, int)
{
    private int value;
    int get() @property { return value;}
    void set(int _value) { value = _value;}
}
*/

gs.set(1);
assert( gs.get == 1);
\end{dcode}

\subsection{Limitations}\label{stringmixinslimitations}

Code crafting is still a bit awkward\index{string mixins!limitations}, because I haven't introduced CTFE yet (see \ref{ctfe}). So we are limited to simple concatenation for now: looping for example is possible with templates, but far easier with CTFE. Even then, it's already wonderfully powerful: you can craft D code with some `holes' (types, names, whatever) that will be completed by a template instantiation and then mixed in elsewhere. You can create other any kind of D code with that.

You can put \D{mixin}\DD{()} expressions almost were you want to, but\ldots

\TODO{Test the limits:inside static if expressions, for example}


\aparte{Escaping strings}{One usual problem with manipulating D code as string is how to deal with strings in code? You must escape them. Either use \DD{\textbackslash"} to create string quotes, a bit like was done in section \ref{functiontemplatessyntax} to generate the error message for \DD{select}. Or you can put strings between \DD{q\{} and \DD{\}}. }

\section{Compile-Time Function Evaluation} \label{ctfe}

\subsection{Evaluation at Compile-Time} \label{compiletimeevaluation}

Compile-Time Function Evaluation\index{CTFE}\index{Compile-Time Function Evaluation} (from now on, CTFE) is an extension of the constant-folding that's done during compilation\index{compile-time!constant folding} in D code: if you can calculate \DD{1 + 2 + 3*4} at compile-time, why not extend it to whole functions evaluation? I'll call evaluable at compile-time functions CTE functions from now on.

It's a very hot topic in D right now and the reference compiler has advanced by leaps and bounds in 2011. The limits to what can be done with CTE functions are pushed farther away at each new release.  All the \D{foreach}, \D{while}, \D{if}/\D{then}/\D{else} statements, arrays manipulation, struct manipulation, function manipulation\ldots are there. You can even do pointer arithmetics! When I began this document (DMD 2.055), the limitations\index{CTFE!limitations} were mostly: no classes and no exceptions (and so, no \DD{enforce}). This was changed with DMD 2.057, allowing the manipulation of classes at compile-time.

In fact danger lies the other way round: it's easy to forget that CTE functions must also be standard, runtime, functions. Remember that some actions only make sense at compile-time or with compile-time initialized constants: indexing on tuples for example:

\subsection{\D{\_\_ctfe}}

\unfinished{Write something on this new functionality, which enables testing inside a function whether we are at compile-time or runtime.}

\subsection{Templates and CTFE} \label{templatesandctfe}
\index{CTFE!and templates}
\index{template!and CTFE}

\unfinished{Some juicy examples should be added.}

That means: you can feed compile-time constants to your classical D function and its code will be evaluated at compile-time. As far as templates are concerned, this means that function return values can be used as template parameters and as \D{enum} initializers:

\index{example!CTFE}
\begin{dcode}

\end{dcode}

Template functions can very well give rise to functions evaluated at compile-time:

\begin{dcode}
\end{dcode}

\subsection{Templates and CTFE and String Mixins, oh my!}
\label{templatesandctfeandstringmixins}

And the fireworks is when you mix (!) that with string mixins: code can be generated by functions, giving access to almost the entire D language to craft it. This code can be mixed in templates to produce what you want. And, to close the loop: the function returning the code-as-string can itself be a template, using another template parameters as its own parameters.

Concretly, here is the getting-setting code from section \ref{stringmixinsandtemplates}, reloaded:

\begin{dcode}
enum GetSet { no, yes}

string priv(string type, string index)
{
    return 
    "private "~type~"value"~index~";\n"
  ~ type~" get"~index~"() @property { return value"~index~";}\n"
  ~ "void set"~index~"("~type~" _value) { value"~index~" = _value;}";
}   

string pub(string type, string index)
{
    return type ~ "value" ~ index ~ ";";
}

string GenerateS(GetSet getset = GetSet.no, T...)()
{
    string result;    
    foreach(index, Type; T)
        static if (getset = GetSet.yes)
		     result ~= priv(Type.stringof, to!string(index));
        else
            result ~= pub(Type.stringof, to!string(index));
    return result;
}

struct S(GetSet getset = GetSet.no, T...)
{
    mixin(GenerateS!(getset,T));
}

S!(GetSet.yes, int, string, int) gs;
/* Generates:

struct S!(GetSet.yes, int, string, int)
{
    private int value0;
    int get0() @property { return value0;}
    void set0(int _value) { value0 = _value;}

    private string value1;
    string get1() @property { return value1;}
    void set1(string _value) { value1 = _value;}

    private int value2;
    int get2() @property { return value2;}
    void set2(int _value) { value2 = _value;}
}
*/

gs.set1("abc");
assert(gs.get1 == "abc");
\end{dcode}

This code is much more powerful than the one we saw in section \ref{stringmixinsandtemplates}: the number of types is flexible, and an entire set of getters/setters is generated when asked to. All this is done by simply plugging \D{string}-returning functions together, and a bit of looping by way of a compile-time \D{foreach}.

\subsection{Simple String Interpolation}

All this play with the concatenating operator (\DD{~}) is becoming a drag. We should write a string interpolation function, evaluable at compile-time of course, to help us in our task. Here is how I want to use it:

\begin{dcode}
alias interpolate!"struct #0 { #1 value; #0[#2] children;}" makeTree;

enum string intTree = makeTree("IntTree", "int", 2);
enum string doubleTree = makeTree("DoubleTree", "double", "");

assert(intTree 
       == "struct IntTree { int value; IntTree[2] children;}");
assert(doubleTree 
       == "struct DoubleTree { double value; IntTree[] children;}");
\end{dcode}

As you can see, the string to be interpolated is passed as a template parameter. Placeholders use a character normally not found in D code: \DD{\#}. The $n^{th}$ parameter is \DD{\#n}, starting from 0. As a concession to practicality, a lone \DD{\#} is considered equivalent to \DD{\#0}. Args to be put into the string are passed as standard (non-template) parameters and can be of any type.

\begin{dcode}
template interpolate(string code)
{
    string interpolate(Args...)(Args args) {
        string[] stringified;
        foreach(index, arg; args) stringified ~= to!string(arg);

        string result;
        int i;

        while (i < code.length) {
            if (code[i] == '#') {
                int j = 1;
                int index;
                auto zero = to!int('0');
                while (i+j < code.length
                    && to!int(code[i+j])-zero >= 0
                    && to!int(code[i+j])-zero <= 9)
                {
                    index = index*10 + to!int(code[i+j])-zero;
                    ++j;
                }

                result ~= stringified[index];
                i += j;
            }
            else {
                result ~= code[i];
                ++i;
            }
        }

        return result;
    }
}
\end{dcode}

\TODO{The syntax could be extended somewhat: inserting multiple strings, inserting a range of strings, all arguments to the end.}

\subsection{Example: extending \DD{std.functional.binaryFun}}\label{naryfun}

\unfinished{This one is dear to my heart. Mapping $n$ ranges in parallel is one of the first things that I wanted to do with ranges, for examples to create ranges of structs with constructor taking more than one parameter.}

Phobos has two really interesting templates: \stdanchor{functional}{unaryFun} and \stdanchor{functional}{binaryFun}.

\TODO{Explain that this aims to extend that to n-args functions.}


\begin{dcode}
bool isaz(char c) {
    return c >= 'a' && c <= 'z';
}

bool isAZ(char c) {
    return c >= 'A' && c <= 'Z';
}

bool isNotLetter(char c) {
    return !isaz(c) && !isAZ(c);
}

int letternum(char c) {
    return to!int(c) - to!int('a') + 1;
}

int arity(string s) {
    if (s.length == 0) return 0;

    int arity;
    string padded = " " ~ s ~ " ";
    foreach(i, c; padded[0..$-2])
        if (isaz(padded[i+1]) 
         && isNotLetter(padded[i]) 
         && isNotLetter(padded[i+2]))
            arity = letternum(padded[i+1]) > arity ? 
                    letternum(padded[i+1]) 
                  : arity;
    return arity;
}

string templateTypes(int arit) {
    if (arit == 0) return "";
    if (arit == 1) return "A";

    string result;
    foreach(i; 0..arit)
        result ~= "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i] ~ ", ";

    return result[0..$-2];
}

string params(int arit) {
    if (arit == 0) return "";
    if (arit == 1) return "A a";

    string result;
    foreach(i; 0..arit)
        result ~= "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i]
               ~ " " ~ "abcdefghijklmnopqrstuvwxyz"[i]
               ~ ", ";

    return result[0..$-2];
}

string naryFunBody(string code, int arit) {
    return interpolate!"auto ref naryFun(#0)(#1) { return #2;}"
                      (templateTypes(arit), params(arit), code);
}

template naryFun(string code, int arit = arity(code))
{
    mixin(naryFunBody(code, arit));
}
\end{dcode}

\section{\D{\_\_traits}}\label{traits}

\unfinished{I should maybe add an example about how to get all parents from a class type. Also, iterating on all members of a type, or extracting types and names from an aggregate (a module, a class or a struct).}

The general \D{\_\_traits} syntax can be found online \href{www.dlang.org/traits.html}{here}. Traits are basically another compile-time introspection\index{compile-time!introspection!with \_\_traits@with \D{\_\_traits}}\index{introspection!with \_\_traits@with \D{\_\_traits}} tool, complementary to the \D{is} expression (see appendix \ref{isexpression}). Most of time, \D{\_\_traits} will return \D{true} or \D{false} for simple type-introspection questions (is this type or symbol an abstract class, or a final function?). As D is wont to do, these questions are sometimes ones you could ask using \D{is} or template constraints, but sometimes not. What's interesting is that you can do some introspection on types, but also on symbols or expressions.

Seeing how this is a document on templates and that we have already seen many introspection tools, here is a quick list of what yes/no questions you can ask which can or \emph{cannot} be tested with \D{is}:\footnote{As with any other affirmation in this document, readers should feel free to prove me wrong. That shouldn't be too difficult.}

\begin{table}[htb]
\centering
\begin{tabular}[c]{|c|c|}
\hline
Question & Doable with other tools? \\
\hline
\hline
isArithmetic & Yes \\
isAssociativeArray & Yes \\
isFloating & Yes \\
isIntegral & Yes \\
isScalar & Yes \\
isStaticArray & Yes \\
isUnsigned & Yes \\
\hline
\hline
isAbstractClass & No \\
isFinalClass & No \\
isVirtualFunction & No \\
isAbstractFunction & No \\
isFinalFunction & No \\
isStaticFunction & No \\
\hline
\hline
isRef & No \\
isOut & No \\
isLazy & No \\
\hline
\hline
hasMember & No (Yes?) \\
isSame & No \\
compiles & Yes (in a way) \\
\hline
\end{tabular}
\caption{Comparison between \D{\_\_traits} and other introspection tools}
\label{table:traits}
\end{table}


More interesting in my opinion is using \D{\_\_traits} to get new information from the type. These are really different from other introspection tools and I will deal with them in more detail right now.

\begin{itemize}
\item identifier (example with foo)
\item getMember (returns an expression)
\item getOverloads (returns an array of overloads)
\item getVirtualFunctions (returns an arrays of the virtual overloads)
\item parent (get the parent directly). Example: recurse upwards.
\item allMembers (tuple of string literals, names of members of a type. If it's a class, it will include inherited members. No repetition -> getOverloads). Example: store all members in a hashtable or a polymorphic association list. As a mixin, to be put inside types to enable runtime reflection? (a.send("someMethod", args), a.setInstanceVariable("a",5))
\item derivedMembers (tuple of string literals, names of members of type. If it's a class it will \emph{not} include inherited members. No repetition -> getOverloads)
\end{itemize}

Example: iterating on members, extracting types from an aggregate.

\section{Wrapping it all Together}\label{wrappingitup}

\unfinished{Here is what I want to show: using traits to crack a type open, templated CT functions to generate strings to be mixed-in, cloning a type.}
